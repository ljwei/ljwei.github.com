<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="machine learning | python | ai | math" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> Jerry's BLOG </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Jerry's BLOG</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分类
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/10/machine-learning/machine-learning-application/机器学习应用之语义分析/">
                机器学习应用之语义分析
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/machine-learning/">machine learning</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/10/machine-learning/machine-learning-application/机器学习应用之语义分析/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/10/machine-learning/machine-learning-application/机器学习应用之语义分析/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>语义分析是指运用各种机器学习方法，挖掘与学习文本、图片等的深层次概念。属于自然语言处理的范畴，但是在很多场景中，都需要用到语义分析，本文梳理语义分析的有关内容。</p>
<h1 id="数据类型">数据类型</h1><p>应用机器学习技术来解决问题，离不开数据的支撑。在计算机的世界中，最主要的数据类型包括：</p>
<ul>
<li>文本</li>
<li>音频</li>
<li>图片</li>
<li>视频</li>
</ul>
<p>将机器学习的技术应用在上面的每一种数据类型上，再结合实际的需求，都会产生一个应用方向。例如，如果希望对文本数据进行分类，那么就是文本分类；如果希望能识别语音中的信息，那么就是语音识别。虽然每种数据类型对应的处理方法不同，特征提取的方法不同，但是将这些数据类型表示成可被计算机处理的特征表示后，都可以利用合适的机器学习方法来解决，而且在很多地方，这些方法是相通的。例如，很多分类算法既可以用于文本分类，也可以用于图片分类。</p>
<p>机器学习算法是很难直接处理这些数据的，因此需要将这些数据变成更直接更方便处理的格式，也就是特征表示，这就是语义分析的作用。</p>
<h1 id="文本分析">文本分析</h1><p>文本分析首先需要对文本进行一些预处理，主要包括中文分词、词性标注等等内容。然后再根据采用的模型对文档进行建模。</p>
<h2 id="文档模型">文档模型</h2><p>要将文本映射到特征空间，首先得确定要使用怎样的模型来表示文本的特征。常见的特征表示方式有：布尔模型、向量空间模型、概率模型等，但是最常用的是向量空间模型。</p>
<h3 id="布尔模型">布尔模型</h3><p>布尔模型是最早出现的文档表示模型，基本思路就是用一个很大的布尔向量来表示文档，其中向量的每一位为0或1，表示该单词是否出现在了文档中。</p>
<h3 id="向量空间模型（_Vector_Space_Model，VSM）">向量空间模型（ Vector Space Model，VSM）</h3><h4 id="表示模型">表示模型</h4><p>向量空间模型就是用一个向量来表示一篇文档，但是每一位不在是0或1，而是一个权值，最常见的是TF-IDF值。由于文档有意义的基本单位是单词，因此在使用向量表示时，一般以词为单位，如果假设这些词之间没有关联，这就是现在最流行的<strong>词袋模型（BoW，Bag of Words）</strong>。现在词袋模型应用广泛，而且推广到了图像分类中，对应的模型叫做<strong>视觉词袋模型（BoVW，Bag of Visual Words）</strong>。</p>
<p>词袋模型基于这样一个关键假设，即文章中<strong>词条出现的顺序是无关紧要的</strong>，它们对于文本的类别所起的作用是相互独立的，因此可以把文本看作一系列无序词条的集合。在该模型中，文本空间被视为一组正交词条（即词典）向量所张成的向量空间。由于一般数据集中，词典的规模很大，而向量的维数跟词典的大小相同，因而向量的维数往往是惊人的，导致计算量很大，而且词典中包含所有的单词，里面会包含很多噪声，而且特征不明显。</p>
<p>正是由于上面提到的种种问题，需要对这个特征空间进行降维，而这个过程就是下面将提到的特征选择。</p>
<h4 id="特征选择">特征选择</h4><p>特征选择就是从词典中选出最有代表性的单词，以此作为新的词典，这样可以降低特征空间的维数，从而达到降低计算复杂度和提高分类准确率的目的。因此需要一种能准确度量对于数据集来说，重要的词的标准。对于文本分类来说，由于各种统计量很容易计算，而且这些统计量又能很好的表示一些特性，因此常用统计量来进行特征选择。在图像分类中，这样的方法就不太行了。常用的度量有如下一些统计量：</p>
<h5 id="信息增益（IG，Information_Gain）">信息增益（IG，Information Gain）</h5><p>要了解信息增益，先得知道熵。熵是信息论中的概念，用来度量信息的不确定性。对于随机变量C，其熵为：</p>
<p>$$<br>H(C)=-\sum{p(c_i)\log{p(c_i)}}<br>$$</p>
<p>利用熵就可以知道系统当前的状态，但是要怎样度量一个状态的变化呢？那就必须要知道，给定条件T下的熵，而这就是条件熵：</p>
<p>$$<br>H(C|T)=\sum{p(t_i)H(C|t_i)}<br>$$</p>
<p>那么，信息增益可表示为：</p>
<p>$$<br>IG(C)=H(C)-H(C|T)<br>$$</p>
<p>对应与文本分类这个具体任务，C表示文档类别，W表示一个单词，W只有两种状态，即这个词在或者不在该类别中。因此上面的式子可写成：</p>
<p>$$<br>IG(C)=H(C)-H(C|W) \<br>＝-\sum{p(c_i)\log{p(c_i)}}</p>
<ul>
<li>p(w)\sum{p(C)\log{p(C|w)}}</li>
<li>p(\overline{w})\sum{p(C)\log{p(C|\overline{w})}}<br>$$</li>
</ul>
<p>IG值越高，表示一个词对分类起到的作用越大，设定一个阈值就可进行过滤掉不重要的词。</p>
<h5 id="词条与类别的互信息（MI，Mutual_information）">词条与类别的互信息（MI，Mutual information）</h5><p>词条W与类别$ math c_i $的互信息为:</p>
<p>$$<br>MI(W, c_i)=\log{\frac{p(W|c_i)}{p(w)}}<br>$$</p>
<p>对整个系统来说，词条W的互信息为:</p>
<p>$$<br>MI_{avg}(W, c_i)=\sum_i{p(c_i)\log{\frac{p(W|c_i)}{p(W)}}}<br>$$</p>
<p>需要选取互信息量最大的名词作为特征词，这样的词在某个类中的出现概率大，而在其他类中出现的概率小。这是因为互信息量越大，名词和类别之间同时出现的概率也越大。</p>
<h5 id="词条的$\chi^2$统计（CHI）">词条的$\chi^2$统计（CHI）</h5><h5 id="词条的期望交叉熵（CE）">词条的期望交叉熵（CE）</h5><p>$$<br>CE(W)=\sum_i{p(c_i|W)\log{\frac{p(c_i|W)}{p(c_i)}}}<br>$$</p>
<p>交叉熵反应了文本类别的概率分布与在出现了某个词条的情况下文本类别的概率分布之间的距离。词条的交叉熵越大，对文本类别分布影响也就越大。所以选CE最大的K个词条作为最终的特征项。</p>
<h4 id="特征权重计算">特征权重计算</h4><p>特征选择中选择的是对整个系统来说最重要的K个词（最能区分各个类别的词），那么接下来的工作就是将每篇文档映射到K维特征空间中，即用一个K维向量来表示，每维代表了该篇文档在这个维度上的权重。那么怎样来计算这个权重呢？最常用的是词频-逆文档频率（TF-IDF）。</p>
<h3 id="概率分布模型">概率分布模型</h3><p>词袋模型在需要深层分析的场合就会显得太过简化了。例如在语义分析里，“你打了我”和“我打了你”，意思是相反的，但用词袋模型表示后，这两句话是向量表示的等价的，这显然是不合理的。因此提出了n元模型，以及现在应用广泛的LDA主题模型。关于这部分的内容很多，网上可以找多很多很好的文章。</p>
<h1 id="图片理解">图片理解</h1><p>todo</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/04/machine-learning/machine-learning-application/机器学习应用概述/">
                机器学习应用概述
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/machine-learning/">machine learning</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/04/machine-learning/machine-learning-application/机器学习应用概述/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/04/machine-learning/machine-learning-application/机器学习应用概述/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>如今，机器学习技术已经慢慢普及，在生活中的很多地方都能看到机器学习的应用。本文就来简单盘点一下，机器学习有哪些主要的应用领域。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/04/machine-learning/machine-learning-application/机器学习应用概述/#more">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/04/machine-learning/machine-learning-algorithms/机器学习算法分类/">
                机器学习算法分类
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/machine-learning/">machine learning</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/04/machine-learning/machine-learning-algorithms/机器学习算法分类/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/04/machine-learning/machine-learning-algorithms/机器学习算法分类/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>[toc]</p>
<p>机器学习的算法有很多，本文先简单介绍机器学习算法的类别。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/04/machine-learning/machine-learning-algorithms/机器学习算法分类/#more">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/03/machine-learning/machine-learning-theory/统计学习基础/">
                机器学习理论
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-03
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/machine-learning/">machine learning</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/03/machine-learning/machine-learning-theory/统计学习基础/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/03/machine-learning/machine-learning-theory/统计学习基础/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>[toc]</p>
<p>机器学习虽然涉及的知识点很多，但是在应用机器学习时，有一些共同的问题需要考虑，这也构成了机器学习的基础理论。先了解机器学习的一些共性问题和基础理论，对于理解机器学习有很大的帮助。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/03/machine-learning/machine-learning-theory/统计学习基础/#more">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/03/machine-learning/机器学习概览/">
                机器学习概览
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-03
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/machine-learning/">machine learning</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/03/machine-learning/机器学习概览/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/03/machine-learning/机器学习概览/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>机器学习的涉及的内容很多，为了方便之后回顾，决定对相关的知识进行梳理，并用一系列的文章记录下来。这个工作量很大，希望能坚持下来！</p>
<p>我将从以下四个方面来介绍机器学习：</p>
<ul>
<li>机器学习理论：机器学习的基本理论问题</li>
<li>机器学习算法：机器学习各种算法简介</li>
<li>机器学习技法：在机器学习中，经常要用到的一些技法</li>
<li>机器学习应用：机器学习的应用很广泛，简单介绍最常见的一些应用</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/01/设计模式/">
                设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-01
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/01/设计模式/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/01/设计模式/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="设计模式">设计模式</h1><h2 id="分类">分类</h2><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p>
<p>1    创建型模式<br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。<br>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</p>
<p>2    结构型模式<br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。<br>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</p>
<p>3    行为型模式<br>这些设计模式特别关注对象之间的通信。<br>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</p>
<h2 id="六大原则">六大原则</h2><p>1、开闭原则（Open Close Principle）<br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p>2、里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>3、依赖倒转原则（Dependence Inversion Principle）<br>这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p>5、迪米特法则，又称最少知道原则（Demeter Principle）<br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、合成复用原则（Composite Reuse Principle）<br>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h2 id="常见设计模式简介">常见设计模式简介</h2><h3 id="工厂模式">工厂模式</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br>主要解决：主要解决接口选择的问题。<br>何时使用：我们明确地计划不同条件下创建不同实例时。<br>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。<br>关键代码：创建过程在其子类执行。<br>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br>使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。<br>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h3 id="抽象工厂模式">抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>主要解决：主要解决接口选择的问题。<br>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br>如何解决：在一个产品族里面，定义多个产品。<br>关键代码：在一个工厂里聚合多个同类产品。<br>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<br>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br>注意事项：产品族难扩展，产品等级易扩展。</p>
<h3 id="单例模式">单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>主要解决：一个全局使用的类频繁地创建与销毁。<br>何时使用：当您想控制实例数目，节省系统资源的时候。<br>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br>关键代码：构造函数是私有的。<br>应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。<br>优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。<br>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br>使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<h3 id="原型模式">原型模式</h3><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>主要解决：在运行期建立和删除原型。<br>何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。<br>如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br>关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。<br>应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。<br>优点： 1、性能提高。 2、逃避构造函数的约束。<br>缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。<br>使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。<br>注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<h3 id="适配器模式">适配器模式</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<p>意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br>何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）<br>如何解决：继承或依赖（推荐）。<br>关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。<br>应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。<br>优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。<br>缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。<br>使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。<br>注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h3 id="桥接模式">桥接模式</h3><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
<p>意图：将抽象部分与实现部分分离，使它们都可以独立的变化。<br>主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。<br>何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。<br>如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。<br>关键代码：抽象类依赖实现类。<br>应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。<br>优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。<br>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br>使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h3 id="组合模式">组合模式</h3><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。<br>何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br>如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。<br>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。<br>应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。<br>优点： 1、高层模块调用简单。 2、节点自由增加。<br>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。<br>使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。<br>注意事项：定义时为具体类。</p>
<h3 id="装饰器模式">装饰器模式</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br>何时使用：在不想增加很多子类的情况下扩展类。<br>如何解决：将具体功能职责划分，同时继承装饰者模式。<br>关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。<br>应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。<br>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br>缺点：多层装饰比较复杂。<br>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。<br>注意事项：可代替继承。<br>∑</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/01/algorithm/常见算法题/">
                常见算法和数据结构
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-01
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/01/algorithm/常见算法题/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/01/algorithm/常见算法题/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>[toc]</p>
<h1 id="基本知识点">基本知识点</h1><ul>
<li>算法分析<ul>
<li>主方法</li>
</ul>
</li>
<li>算法设计<ul>
<li>递推</li>
<li>分治</li>
<li>动规</li>
<li>贪心</li>
</ul>
</li>
<li>排序算法<ul>
<li>冒泡</li>
<li>选择</li>
<li>插入</li>
<li>归并</li>
<li>shell</li>
<li>快排</li>
<li>堆排序：1.求TopK;2.k路归并</li>
</ul>
</li>
<li>数据结构<ul>
<li>数组、链表、</li>
<li>栈和队列</li>
<li>堆（优先队列）œ</li>
<li>散列</li>
<li>BST</li>
<li>红黑树</li>
<li>B树</li>
</ul>
</li>
<li>图算法</li>
<li>数论算法</li>
<li>字符串匹配</li>
<li>近似算法</li>
</ul>
<h1 id="面试算法题">面试算法题</h1><h2 id="集合求交">集合求交</h2><p><strong>A，B两个整数集合，设计一个算法求他们的交集，尽可能的高效。</strong></p>
<ul>
<li>空间：bitmap</li>
<li>时间：<ul>
<li>有序：<ul>
<li>二路归并</li>
<li>利用二分查找的方法，在数组B中查找,注意在数组B中，使用二分查找的起点，是根据上次查找的结果开确定的；这样可以进一步提高速度；</li>
</ul>
</li>
<li>无序：将小的集合构成hashset，对大的集合遍历</li>
</ul>
</li>
</ul>
<h2 id="数论类">数论类</h2><h3 id="连续整数和">连续整数和</h3><p><strong>连续整数之和为1000的共有几组？（m，n都为正整数）</strong></p>
<p>连续整数之和m到n, 通项公式为S=(n+m)(m-n+1)/2,这里S=1000。得:<br>（n+m)(m-n+1) = 2000 = 2^4 * 5 ^3,可以看出这两个数必须满足一个奇数，一个偶数，这里取i=0,1,2,3,i为5的指数<br>1: i=0,奇数=1，偶数=2000，n+m=2000, m-n+1=1,得m=n=1000(这个算吗？貌似答案算了)<br>2:i=1,奇数=5，偶数=400，n+m=400, m-n+1=5,m=203,n=197<br>3:i=2,奇数=25，偶数=80，n+m=80, m-n+1=25 ,m=53,n=27<br>4:i=3,奇数=125，偶数=160，n+m=16, m-n+1=125 ,m=71,n=54</p>
<h3 id="一个有序数列，序列中的每一个值都能够被2或者3或者5所整除，这个序列的初始值从1开始，但是1并不在这个数列中。求第1500个值是多少？">一个有序数列，序列中的每一个值都能够被2或者3或者5所整除，这个序列的初始值从1开始，但是1并不在这个数列中。求第1500个值是多少？</h3><p>2、3、5的最小公倍数是30。[ 1, 30]内符合条件的数有22个。如果能看出[ 31, 60]内也有22个符合条件的数，那问题就容易解决了。也就是说，这些数具有周期性，且周期为30.<br>       第1500个数是：1500/22=68   1500%68=4。也就是说：第1500个数相当于经过了68个周期，然后再取下一个周期内的第4个数。一个周期内的前4个数：2,3,4,5。<br>故，结果为68*30=2040+5=2045</p>
<h2 id="设计类">设计类</h2><h3 id="排队系统">排队系统</h3><p><strong>请设计一个排队系统，能够让每个进入队伍的用户都能看到自己在队列中所处的位置和变化，队伍可能随时有人加入和退出；当有人退出影响到用户的位置排名时需要及时反馈到用户</strong></p>
<p>设计一个链式的队列，由于队列频繁的有人来和走（插入和删除），所以链式队列的效率最好，队列中存放的元素是一个对象和队长，这个对象包括了 Person、location属性，Person是排队的用户，而location是用户的位置，当有用户进来的时候，只能从队尾进入，此时将他的 Person对象加入，其location等于队长加1，并且队长加1；如果有用户退出（任何位置），找到退出的用户的前一个用户，删除退出用户的结点， 并且其后的其他用户的location-1，队长也-1.<br>为了更快的找到退出的用户，可以考虑用HashMap存储用户的key：Hash值，val：链表结点的位置。</p>
<h2 id="NIM游戏的必胜策略">NIM游戏的必胜策略</h2><h2 id="生产者消费者模型">生产者消费者模型</h2><p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题，常用的方法有信号灯法等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p>
<h3 id="使用信号灯的算法">使用信号灯的算法</h3><p>信号灯可以避免上述唤醒指令不起作用的情况。该方法（见下面的代码）使用了两个信号灯，fillCount 和 emptyCount。fillCount 用于记录缓冲区中将被读取的数据项数（实际上就是有多少数据项在缓冲区里），emptyCount 用于记录缓冲区中空闲空间数。当有新数据项被放入缓冲区时，fillCount 增加，emptyCount 减少。如果在生产者尝试减少 emptyCount 的时候发现其值为零，那么生产者就进入休眠。等到有数据项被消耗，emptyCount 增加的时候，生产者才被唤醒。消费者的行为类似。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">semaphore fillCount = <span class="number">0</span>; <span class="comment">// 生产的项目</span></span><br><span class="line">semaphore emptyCount = BUFFER_SIZE; <span class="comment">// 剩余空间</span></span><br><span class="line"></span><br><span class="line">procedure producer<span class="params">()</span> &#123;</span><br><span class="line">    while <span class="params">(<span class="literal">true</span>)</span> &#123;</span><br><span class="line">        item = produceItem<span class="params">()</span>;</span><br><span class="line">        down<span class="params">(emptyCount)</span>;</span><br><span class="line">            putItemIntoBuffer<span class="params">(item)</span>;</span><br><span class="line">        up<span class="params">(fillCount)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">procedure consumer<span class="params">()</span> &#123;</span><br><span class="line">    while <span class="params">(<span class="literal">true</span>)</span> &#123;</span><br><span class="line">        down<span class="params">(fillCount)</span>;</span><br><span class="line">            item = removeItemFromBuffer<span class="params">()</span>;</span><br><span class="line">        up<span class="params">(emptyCount)</span>;</span><br><span class="line">        consumeItem<span class="params">(item)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法在只有一个生产者和一个消费者时能解决问题。对于多个生产者或者多个消费者共享缓冲区的情况，该算法也会导致竞争条件，出现两个或以上的线程同时读或写同一个缓冲区槽的情况。为了说明这种情况是如何发生的，可以假设 putItemIntoBuffer() 的一种可能的实现：先寻找下一个可用空槽，然后写入数据项。下列情形是可能出现的：</p>
<ul>
<li>两个生产者都减少 emptyCount 的值；</li>
<li>某一生产者寻找到下一个可用空槽；</li>
<li>另一生产者也找到了下一个可用空槽，结果和上一步被找到的是同一个空槽；</li>
<li>两个生产者向可用空槽写入数据。</li>
</ul>
<p>为了解决这个问题，需要在保证同一时刻只有一个生产者能够执行 putItemIntoBuffer()。也就是说，需要寻找一种方法来互斥地执行临界区的代码。为了达到这个目的，可引入一个二值信号灯 mutex，其值只能为 1 或者 0。如果把线程放入 down(mutex) 和 up(mutex) 之间，就可以限制只有一个线程能被执行。多生产者、消费者的解决算法如下：</p>
<pre><code>semaphore mutex = <span class="number">1</span>;
semaphore fillCount = <span class="number">0</span>;
semaphore emptyCount = BUFFER_SIZE;


procedure producer<span class="params">()</span> {
    while <span class="params">(<span class="literal">true</span>)</span> {
        item = produceItem<span class="params">()</span>;
        down<span class="params">(emptyCount)</span>;
            down<span class="params">(mutex)</span>;
                putItemIntoBuffer<span class="params">(item)</span>;
            up<span class="params">(mutex)</span>;
        up<span class="params">(fillCount)</span>;
    }
}
procedure consumer<span class="params">()</span> {
    while <span class="params">(<span class="literal">true</span>)</span> {
        down<span class="params">(fillCount)</span>;
            down<span class="params">(mutex)</span>;
                item = removeItemFromBuffer<span class="params">()</span>;
            up<span class="params">(mutex)</span>;
        up<span class="params">(emptyCount)</span>;
        consumeItem<span class="params">(item)</span>;
    }
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/04/01/计算机基础知识/">
                计算机基础知识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-04-01
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/04/01/计算机基础知识/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/01/计算机基础知识/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>[toc]</p>
<h1 id="数据库">数据库</h1><h2 id="基本概念">基本概念</h2><p>概念模型：也称信息模型，是按用户的观点来对数据和信息建模，主要用于数据库设计。</p>
<p>逻辑模型：是按计算机系统的观点对数据建模，用于DBMS实现。</p>
<p>物理模型：是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。</p>
<p>E-R图：即实体-关系图，用于描述现实世界的事物及其相互关系，是数据库概念模型设计的主要工具。</p>
<h2 id="数据库三级模式和两级映像">数据库三级模式和两级映像</h2><p>数据库的三级系统结构：外模式、模式和内模式。</p>
<p>数据库模式：是对数据库中全体数据的逻辑结构（数据项的名字、类型、取值范围等）和特征（数据之间的联系以及数据有关的安全性、完整性要求）的描述。</p>
<p>数据库内模式：又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。</p>
<p>数据库外模式：又称为子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。通常是模式的子集。一个数据库可有多个外模式。</p>
<p>数据库的二级映像：外模式/模式映像实现逻辑独立性、模式/内模式映像实现物理独立性。</p>
<h2 id="范式">范式</h2><p><strong>第一范式（1NF）无重复的列</strong><br>第一范式（1NF）中数据库表的每一列都是不可分割的基本数据项<br>同一列中不能有多个值<br>即实体中的某个属性不能有多个值或者不能有重复的属性。<br>简而言之，第一范式就是无重复的列。<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p><strong>第二范式（2NF）属性完全依赖于主键[消除部分子函数依赖]</strong><br>满足第二范式（2NF）必须先满足第一范式（1NF）。<br>第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。<br>为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。<br>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。</p>
<p><strong>第三范式（3NF）属性不依赖于其它非主属性[消除传递依赖]</strong><br>满足第三范式（3NF）必须先满足第二范式（2NF）。<br>简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。<br>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。</p>
<h1 id="计算机网络">计算机网络</h1><h2 id="ip地址类型">ip地址类型</h2><p>1．A类IP地址</p>
<p>　　一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围1.0.0.1-126.255.255.254（二进制表示为：00000001 00000000 00000000 00000001 - 01111110 11111111 11111111 11111110）。可用的A类网络有126个，每个网络能容纳1677214个主机。</p>
<p>2．B类IP地址</p>
<p>　　一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围128.1.0.1-191.255.255.254（二进制表示为：10000000 00000001 00000000 00000001 - 10111111 11111111 11111111 11111110）。可用的B类网络有16384个，每个网络能容纳65534主机 。</p>
<p>3．C类IP地址</p>
<p>　　一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围192.0.1.1-223.255.255.254（二进制表示为: 11000000 00000000 00000001 00000001 - 11011111 11111111 11111110 11111110）。C类网络可达2097152个，每个网络能容纳254个主机。</p>
<p>4．D类地址用于多点广播（Multicast）。</p>
<p>　　D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。</p>
<p>　　地址范围224.0.0.1-239.255.255.254</p>
<p>5．E类IP地址</p>
<p>　　以“1111”开始，为将来使用保留。</p>
<p>　　E类地址保留，仅作实验和开发用。</p>
<p>　　全零（“0．0．0．0”）地址指任意网络。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。
　　</p>
<h2 id="HTTP协议返回状态码">HTTP协议返回状态码</h2><h3 id="请求报文">请求报文</h3><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>
<h3 id="响应报文">响应报文</h3><p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文</li>
</ul>
<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>
<p>常见的状态码有如下几种：</p>
<p>200 OK 客户端请求成功<br>301 Moved Permanently 请求永久重定向<br>302 Moved Temporarily 请求临时重定向<br>304 Not Modified 文件未修改，可以直接使用缓存的文件。<br>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。<br>401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因<br>404 Not Found 请求的资源不存在，例如，输入了错误的URL<br>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。<br>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</p>
<h2 id="OSI模型">OSI模型</h2><p>第7层 应用层(Application Layer)<br>提供为应用软件而设的界面，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。</p>
<p>第6层 表示层(Presentation Layer)<br>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>
<p>第5层 会话层(Session Layer)<br>负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</p>
<p>第4层 传输层(Transport Layer)<br>把传输表头(TH)加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议义(TCP) 等。</p>
<p>第3层 网络层(Network Layer)<br>决定数据的路径选择和转寄，它网络表头(NH)加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议(IP) 等。</p>
<p>第2层 数据链路层(Data Link Layer)<br>负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成了帧。数据链表头(DLH)是包含了物理地址和错误侦测及改错的方法。数据链表尾(DLT)是一串指示数据包末端的字符串。例如以太网、无线局域网(Wi-Fi)和通用分组无线服务(GPRS)等。</p>
<p>第1层 物理层(Physical Layer)<br>在局部局域网上传送帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等</p>
<h1 id="编译原理与自动机">编译原理与自动机</h1><h2 id="语言类型">语言类型</h2><p>0型文法：短文文法<br>1型文法：上下文有关文法<br>2型文法：上下文无关文法，它对应于下推自动机<br>3型文法：正规文法，它对应于有限状态自动机</p>
<h1 id="操作系统">操作系统</h1><h2 id="线程共享内容">线程共享内容</h2><p>进程占有的资源：地址空间，全局变量，打开的文件，子进程，信号量，账户信息</p>
<p>线程占有的资源：栈，寄存器，状态，程序计数器</p>
<h2 id="进程调度算法">进程调度算法</h2><p>FCFS: 先来先服务，也可以称为先进先出<br>轮转： 以一个周期性间隔产生时钟中断，此时当前正在运行的进程被置于就绪队列，基于FCFS选择下一个就绪进程             运行。<br>SPN：最短进程优先，下一次选择所需处理时间最短的进程<br>SRT：最短剩余时间优先，总是选择预期剩余时间最短的进程<br>HRRN：最高响应比优先，R=(w+s)/s，其中R表示响应比，w表示已经等待的时间，s表示期待服务的时间<br>反馈：进程第一次进入系统是放置于RQ0,第一次被强占并返回就绪态时，放入RQ1，以后每次被强占就下降一级。如果进程处于最低等级，则不再降级，反复返回到该队列，直到结束。</p>
<h2 id="虚拟内存中的四种典型页替换算法">虚拟内存中的四种典型页替换算法</h2><p>OPT：最佳替换算法（optional replacement）。替换下次访问距当前时间最长的页。opt算法需要知道操作系统将来的事件，显然不可能实现，只作为一种衡量其他算法的标准。</p>
<p>LRU:最近最少使用(Least Recently Used).替换上次使用距离当前最远的页。根据局部性原理：替换最近最不可能 访问到的页。性能最接近OPT，但难以实现。可以维护一个关于访问页的栈或者给每个页添加最后访问的时间标签，但开销都很大。</p>
<p>FIFO:先进先出(First In First Out),将页面看做一个循环缓冲区，按循环方式替换。这是实现最为简单的算法，隐含的逻辑是替换驻留在内存时间最长的页。但由于一部分程序或数据在整个程序的生命周期中使用频率很高，所以会导致反复的换入换出。</p>
<p>Clock：时钟替换算法（Clock）,给每个页帧关联一个使用位。当该页第一次装入内存或者被重新访问到时，将使用位置为1。每次需要替换时，查找使用位被置为0的第一个帧进行替换。在扫描过程中，如果碰到使用位为1的帧，将使用位置为0，在继续扫描。如果所谓帧的使用位都为0，则替换第一个帧。</p>
<h2 id="进程/线程同步机制与进程间通信机制比较">进程/线程同步机制与进程间通信机制比较</h2><p>在多道程序设计系统中，同一时刻可能有许多进程，这些进程之间存在两种基本关系：竞争关系和协作关系。</p>
<p>进程的互斥、同步、通信都是基于这两种基本关系而存在的，为了解决进程间竞争关系（间接制约关系）而引入进程互斥；为了解决进程间松散的协作关系( 直接制约关系)而引入进程同步；为了解决进程间紧密的协作关系而引入进程通信。</p>
<p>第一种是竞争关系 </p>
<p>系统中的多个进程之间彼此无关，它们并不知道其他进程的存在，并且也不受其他进程执行的影响。例如，批处理系统中建立的多个用户进程， 分时系统中建立的多个终端进程。由于这些进程共用了一套计算机系统资源，因而， 必然要出现多个进程竞争资源的问题。当多个进程竞争共享硬设备、存储器、处理器 和文件等资源时，操作系统必须协调好进程对资源的争用。</p>
<p>资源竞争出现了两个控制问题：一个是死锁 （deadlock ）问题，一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。另一个是饥饿（starvation ）问题，这是指这样一种情况：一个进程由于其他进程总是优先于它而被无限期拖延。</p>
<p>第二种是协作关系          </p>
<p>某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协 调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行。这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。</p>
<p>不难看出，进程互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。</p>
<h3 id="线程同步">线程同步</h3><p>1、临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p>
<p>在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p>
<p>2、互斥量：采用互斥对象机制。</p>
<p>只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p>
<p>3、信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 .</p>
<p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p>
<p>PV操作及信号量的概念都是由荷兰科学家E.W.Dijkstra提出的。信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。<br>　　 P操作申请资源：<br>　　（1）S减1；<br>　　（2）若S减1后仍大于等于零，则进程继续执行；<br>　　（3）若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。<br>　　<br>　　V操作 释放资源：<br>　　（1）S加1；<br>　　（2）若相加结果大于零，则进程继续执行；<br>　　（3）若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。<br>　　<br>4、事 件： 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 .</p>
<p>总结：<br>　　1． 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。<br>　　2． 互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和线程退出。<br>　　3． 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。
　　</p>
<h3 id="进程间通信方式">进程间通信方式</h3><p>进程间通信又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:<br>1、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递，例如信号量)<br>2、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).</p>
<ol>
<li>还有一种特殊的跨机器之间的通信机制：套接字</li>
</ol>
<h2 id="死锁">死锁</h2><p>死锁产生的原因主要是：</p>
<pre><code>（1）系统资源不足；
（2） 进程推进顺序非法。
</code></pre><p>产生死锁的必要条件：</p>
<pre><code>（<span class="number">1</span>）互斥（mutualexclusion），一个资源每次只能被一个进程使用；
（<span class="number">2</span>）不可抢占（<span class="keyword">nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺；
</span>（<span class="number">3</span>）占有并等待（hold <span class="keyword">andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；
</span>（<span class="number">4</span>）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。
</code></pre><h1 id="组合数学">组合数学</h1><h2 id="卡特兰数">卡特兰数</h2><h2 id="全排列">全排列</h2>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/03/28/machine-learning/machine-learning-algorithms/统计学习算法概览/">
                统计学习算法概览
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-03-28
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/statistical-learning/">statistical learning</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/03/28/machine-learning/machine-learning-algorithms/统计学习算法概览/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/28/machine-learning/machine-learning-algorithms/统计学习算法概览/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>线性回归</p>
<ul>
<li>类型：线性回归模型</li>
<li>模型：$h_\theta(x)=\theta^T x$</li>
<li>策略：<ul>
<li>损失函数：$J(\theta)=\frac{1}{2}\sum<em>{i=1}^{N}(h</em>\theta(x^{(i)})-y^{(i)})^2)$平方损失函数</li>
<li>学习策略：ERM</li>
</ul>
</li>
<li>算法：最小二乘法，梯度下降法</li>
</ul>
<p>感知机</p>
<ul>
<li>类型：线性分类模型</li>
<li>模型：$h_\theta(x)=sign(\theta^T x)$</li>
<li>策略：<ul>
<li>损失函数：$J(\theta)=-\sum_{i=1}^{N}{y^{(i)}(\theta^Tx^{(i)})}$误分类点到分离超平面的总距离</li>
<li>学习策略：ERM</li>
</ul>
</li>
<li>算法：<ul>
<li>如果训练数据线性可分：随机梯度下降法</li>
<li>如果训练数据非线性可分：pocket算法</li>
</ul>
</li>
</ul>
<p>kNN</p>
<ul>
<li>类型：分类与回归模型</li>
<li>模型：</li>
<li>策略：<ul>
<li>损失函数：</li>
<li>学习策略：ERM</li>
</ul>
</li>
<li>算法：无学习过程</li>
</ul>
<p>朴素贝叶斯</p>
<ul>
<li>类型：分类模型</li>
<li>模型：</li>
<li>策略：<ul>
<li>损失函数：</li>
<li>学习策略：MAP</li>
</ul>
</li>
<li>算法：概率计算</li>
</ul>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/03/27/machine-learning/machine-learning-theory/统计学习之最优化/">
                统计学习之最优化
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2016-03-27
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/03/27/machine-learning/machine-learning-theory/统计学习之最优化/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/27/machine-learning/machine-learning-theory/统计学习之最优化/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>统计学习就是基于训练数据集，根据学习策略，从假设空间中选择最优的模型，最后往往是将一个问题转化成最优化问题，那么就需要借助最优化的知识来求解，这篇文章简单总结一下统计学习中常用的优化算法以及相关的知识。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/03/27/machine-learning/machine-learning-theory/统计学习之最优化/#more">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/avatar.jpg" alt="Jerry" />
          <p class="site-author-name">Jerry</p>
        </div>
        <p class="site-description motion-element">machine learning | python | ai | math</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2016
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Jerry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jw-ml"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
